import io
import os
import signal
from launch import LaunchDescriptor
from launch.launcher import DefaultLauncher
from launch.output_handler import FileOutput
from launch.output_handler import LineOutput


class InMemoryHandler(LineOutput):
    def __init__(self, name, ld, num_expected_lines):
        super(LineOutput, self).__init__()
        self.name = name
        self.ld = ld
        self.num_expected_lines = num_expected_lines
        self.killed = False
        self.left_over_stdout = b''
        self.left_over_stderr = b''
        self.stdout_data = io.BytesIO()
        self.stderr_data = io.BytesIO()

    def on_stdout_lines(self, lines):
        if self.killed:
            return

        for line in lines.splitlines():
            # Filter out stdout that comes from underlying DDS implementations
            if line.startswith(b'pid'):
                continue
            if line.startswith(b'rc'):
                continue
            if line.startswith(b'RTI Data Distribution Service Evaluation ' +
                               b'License issued to'):
                continue
            if line.startswith(b'Expires on'):
                continue
            self.stdout_data.write(line)
            # Add back the newline that was stripped by splitlines()
            self.stdout_data.write(b'\n')

            # Are we ready to quit?
            if (len(self.stdout_data.getvalue().splitlines()) >=
                    self.num_expected_lines):
                # We have enough output to compare; shut down my child
                for td in self.ld.task_descriptors:
                    if td.name == self.name:
                        td.send_signal(signal.SIGINT)
                        self.killed = True
                        break

    def on_stderr_lines(self, lines):
        self.stderr_data.write(lines)

    def get_description(self):
        return 'InMemoryHandler'


def setup():
    os.environ['OSPL_VERBOSITY'] = '8'  # 8 = OS_NONE


def test_executable():
    output_handlers = []
    expected_outputs = []

    ld = LaunchDescriptor()

    i = 0
    for exe, txt in zip(@RCLCPP_EXAMPLES_EXECUTABLE@,
                        @RCLCPP_EXAMPLES_EXPECTED_OUTPUT@):
        name = 'test_executable_' + str(i)
        with open(txt, 'rb') as f:
            expected_outputs.append(f.read().splitlines())
        output_handlers.append(
            InMemoryHandler(name, ld, len(expected_outputs[-1])))
        ld.add_process(
            cmd=[exe, 'test_executable'],
            name=name,
            output_handlers=[output_handlers[-1]],
        )
        i += 1
    
    launcher = DefaultLauncher()
    launcher.add_launch_descriptor(ld)
    rc = launcher.launch()
    
    for handler, expected_output_lines in zip(output_handlers,
                                              expected_outputs):
        output_lines = handler.stdout_data.getvalue().splitlines()
    
        assert rc == 0, \
            "The launch file failed with exit code '" + str(rc) + "'. " \
            'Maybe the client did not receive any messages?'
    
        assert output_lines == expected_output_lines, \
            "Example output (%r) does not match expected output (%r)" % \
            (output_lines, expected_output_lines)

if __name__ == '__main__':
    test_executable()
